"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_table3_1 = __importDefault(require("cli-table3"));
const chalk_1 = __importDefault(require("chalk"));
const histogram_1 = __importDefault(require("./histogram"));
/*
 * The Output module can write a report or a comparison to a given stream based on a configuration.
 */
class Output {
    config;
    stream;
    constructor(config, stream) {
        this.config = config || {};
        this.stream = stream;
    }
    /*
     * Show a report for a given set of results.
     */
    report(results) {
        results.forEach((result) => {
            const { benchmarkInfo: { benchmarkName }, stats, projectConfig: { benchmarkOutput: benchmarkFolder }, } = result;
            // Stats table.
            this.writeStats(benchmarkName, benchmarkFolder, stats);
            // OS & Browser.
            this.writeEnvironment(result.environment);
            // Optional histogram for each line in the stats table.
            if (this.config.outputHistograms) {
                this.writeHistograms(stats);
            }
        });
    }
    /*
     * Write a table of statistics for a single benchmark file.
     */
    writeStats(benchmarkName, resultsFolder, stats) {
        const table = new cli_table3_1.default({
            head: ['Benchmark name', 'Metric (ms)', 'N', 'Mean ± StdDev', 'Median ± MAD'],
            style: { head: ['bgBlue', 'white'] },
        });
        this.generateRows(table, stats.results);
        this.stream.write([
            chalk_1.default.bold.dim('\n Benchmark results for ') + chalk_1.default.bold.magentaBright(benchmarkName),
            chalk_1.default.italic(' ' + resultsFolder + '/'),
            table.toString() + '\n',
        ].join('\n'));
    }
    /*
     * Write browser and CPU load information.
     */
    writeEnvironment({ browser, container }) {
        const cpuLoad = container.load.cpuLoad;
        const loadColor = cpuLoad < 10 ? 'green' : cpuLoad < 50 ? 'yellow' : 'red';
        this.stream.write(' ');
        this.stream.write([
            'Browser version:    ' + chalk_1.default.bold(browser.version),
            `Benchmark CPU load: ${chalk_1.default.bold[loadColor](cpuLoad.toFixed(3) + '%')}`,
        ].join('\n '));
        this.stream.write('\n\n');
    }
    /*
     * Write a set of histograms for a tree of benchmarks.
     */
    writeHistograms(benchmarks, parentPath = '') {
        // const metricPattern = this.config.outputMetricPattern;
        // const histogramPattern = this.config.outputHistogramPattern;
        benchmarks.forEach((benchmark) => {
            const path = `${parentPath}${benchmark.name}`;
            const children = benchmark.benchmarks;
            if (children) {
                this.writeHistograms(children, `${path} > `);
            }
            else {
                // if (!histogramPattern.test(path)) {
                //     return;
                // }
                Object.keys(benchmark).forEach((metric) => {
                    // if (!metricPattern.test(metric)) {
                    //     return;
                    // }
                    const stats = benchmark[metric];
                    if (stats && stats.sampleSize) {
                        const { samples } = stats;
                        const histogram = new histogram_1.default(samples, this.config);
                        const plot = histogram.toString();
                        this.stream.write(`\n${path} > ${metric}\n${plot}\n\n`);
                    }
                });
            }
        });
    }
    /*
     * Recursively populate rows of statistics into a table for a tree of benchmarks.
     */
    generateRows(table, benchmarks, level = 0) {
        // const metricPattern = //this.config.outputMetricPattern;
        benchmarks.forEach((benchmarkNode) => {
            const name = benchmarkNode.name;
            // Root benchmark
            if (benchmarkNode.type === 'benchmark') {
                Object.keys(benchmarkNode.metrics).forEach((metric) => {
                    const metricsStats = benchmarkNode.metrics[metric];
                    const metricValues = metricsStats && metricsStats.stats;
                    if (metricValues && metricValues.sampleSize) {
                        const { sampleSize, mean, median, variance, medianAbsoluteDeviation } = metricValues;
                        table.push([
                            padding(level) + name,
                            chalk_1.default.bold(metric),
                            sampleSize,
                            `${mean.toFixed(3)}` + chalk_1.default.gray(` ± ${((Math.sqrt(variance) / mean) * 100).toFixed(1)}%`),
                            `${median.toFixed(3)}` +
                                chalk_1.default.gray(` ± ${((medianAbsoluteDeviation / median) * 100).toFixed(1)}%`),
                        ]);
                    }
                });
                // Group
            }
            else if (benchmarkNode.type === 'group') {
                const emptyFields = Array.apply(null, Array(4)).map(() => '-');
                table.push([padding(level) + name, ...emptyFields]);
                this.generateRows(table, benchmarkNode.nodes, level + 1);
            }
        });
    }
    /*
     * Show a comparison for a pair of commits.
     */
    compare(result) {
        const { baseCommit, targetCommit } = result;
        const tables = result.comparisons.reduce((tables, node) => {
            if (node.type === 'project' || node.type === 'group') {
                const group = node.comparisons.map((child) => {
                    return this.generateComparisonTable(baseCommit, targetCommit, child);
                });
                return {
                    ...tables,
                    [node.name]: group,
                };
            }
            return tables;
        }, {});
        const flattenedTables = Object.keys(tables).reduce((groups, projectName) => {
            const stringifiedTables = tables[projectName].map((t) => t.toString() + '\n');
            const colorProjectName = chalk_1.default.bold.dim(projectName);
            groups.push(`\nProject: ${colorProjectName}\n`);
            groups.push(...stringifiedTables);
            return groups;
        }, []);
        this.stream.write(flattenedTables.join(''));
    }
    /*
     * Get a comparison table for two different commits.
     */
    generateComparisonTable(baseCommit, targetCommit, stats) {
        const benchmark = stats.name.replace('.benchmark', '');
        const table = new cli_table3_1.default({
            head: [`Benchmark: ${benchmark}`, `base (${baseCommit})`, `target (${targetCommit})`, 'trend'],
            style: { head: ['bgBlue', 'white'] },
        });
        this.generateComparisonRows(table, stats);
        return table;
    }
    /*
     * Recursively populate rows into a table for a tree of comparisons.
     */
    generateComparisonRows(table, stats, groupName = '') {
        if (stats.type === 'project' || stats.type === 'group') {
            stats.comparisons.forEach((node) => {
                if (node.type === 'project' || node.type === 'group') {
                    const name = node.name;
                    this.generateComparisonRows(table, node, name);
                }
                else if (node.type === 'benchmark') {
                    // // row with benchmark name
                    const emptyFields = Array.apply(null, Array(3)).map(() => '-');
                    table.push([chalk_1.default.dim(groupName + '/') + chalk_1.default.bold(node.name), ...emptyFields]);
                    // row for each metric
                    Object.keys(node.metrics).forEach((metric) => {
                        const metrics = node.metrics[metric];
                        if (metrics) {
                            const baseStats = metrics.baseStats;
                            const targetStats = metrics.targetStats;
                            const samplesComparison = metrics.samplesComparison;
                            table.push([
                                padding(1) + metric,
                                `${baseStats.median.toFixed(2)}` +
                                    chalk_1.default.gray(` (± ${baseStats.medianAbsoluteDeviation.toFixed(2)}ms)`),
                                `${targetStats.median.toFixed(2)}` +
                                    chalk_1.default.gray(` (± ${targetStats.medianAbsoluteDeviation.toFixed(2)}ms)`),
                                chalk_1.default.bold(samplesComparison === 0
                                    ? 'SAME'
                                    : samplesComparison === 1
                                        ? chalk_1.default.red('SLOWER')
                                        : chalk_1.default.green('FASTER')),
                            ]);
                        }
                    });
                }
            });
        }
    }
}
exports.default = Output;
function padding(n) {
    return n > 0
        ? Array.apply(null, Array((n - 1) * 3))
            .map(() => ' ')
            .join('') + '└─ '
        : '';
}
//# sourceMappingURL=output.js.map