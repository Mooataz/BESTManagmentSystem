"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildArgs = buildArgs;
exports.run = run;
exports.runCLI = runCLI;
const args_1 = require("./args");
const output_1 = __importDefault(require("./output"));
const yargs_1 = __importDefault(require("yargs"));
const rimraf_1 = __importDefault(require("rimraf"));
const console_stream_1 = require("@best/console-stream");
const utils_1 = require("@best/utils");
const run_best_1 = require("../run_best");
const run_compare_1 = require("../run_compare");
const config_1 = require("@best/config");
function buildArgs(maybeArgv) {
    const parsedArgs = (0, yargs_1.default)(maybeArgv || process.argv.slice(2))
        .usage(args_1.usage)
        .alias('help', 'h')
        .options(args_1.options)
        .epilogue(args_1.docs)
        .check(args_1.check)
        .version(false).argv;
    return (0, args_1.normalize)(parsedArgs);
}
function getProjectListFromCLIArgs(argsCLI, project) {
    const projects = argsCLI.projects.slice();
    if (project) {
        projects.push(project);
    }
    if (!projects.length) {
        projects.push(process.cwd());
    }
    return projects;
}
async function run(maybeArgv, project) {
    try {
        const argsCLI = buildArgs(maybeArgv);
        const projects = getProjectListFromCLIArgs(argsCLI, project);
        await runCLI(argsCLI, projects);
    }
    catch (error) {
        const errParts = error.stack ? error.stack.split('\n') : ['unknown', 'unknown'];
        const errTitle = errParts.shift();
        if (errTitle) {
            (0, utils_1.logError)(errTitle);
        }
        console.warn(errParts.join('\n'));
        process.exit(1);
    }
}
async function runCLI(argsCLI, projects) {
    const outputStream = new console_stream_1.OutputStream(process.stdout);
    let projectConfigs;
    try {
        outputStream.write('Looking for Best configurations...');
        projectConfigs = await (0, config_1.getConfigs)(projects, argsCLI);
    }
    finally {
        outputStream.clearLine();
    }
    const { globalConfig, configs } = projectConfigs;
    if (argsCLI.showConfigs) {
        outputStream.writeln(JSON.stringify({ globalConfig, configs }, null, '  '));
        return process.exit(0);
    }
    if (argsCLI.clearCache) {
        configs.forEach((config) => {
            rimraf_1.default.sync(config.cacheDirectory);
            outputStream.writeln(`Cleared ${config.cacheDirectory}`);
        });
        return process.exit(0);
    }
    const output = new output_1.default({}, outputStream);
    if (argsCLI.compareStats) {
        const results = await (0, run_compare_1.runCompare)(globalConfig, configs, process.stdout);
        if (results) {
            output.compare(results);
        }
    }
    else {
        if (argsCLI.clearResults) {
            outputStream.writeln('Clearing previous benchmark results...');
            configs.forEach((config) => {
                rimraf_1.default.sync(config.benchmarkOutput);
                outputStream.writeln(`- Cleared: ${config.benchmarkOutput}`);
            });
        }
        const results = await (0, run_best_1.runBest)(globalConfig, configs, process.stdout);
        if (!results) {
            throw new Error('AggregatedResult must be present after test run is complete');
        }
        output.report(results);
        if (argsCLI.generateHTML) {
            try {
                const { buildStaticFrontend } = await Promise.resolve().then(() => __importStar(require('@best/frontend')));
                const projectConfig = configs[0];
                await buildStaticFrontend(results, globalConfig, projectConfig, process.stdout);
            }
            catch (_err) {
                throw new Error('You passed the `--generateHTML` flag, but `@best/frontend` is not a dependency. Make sure you include it as a dependency.');
            }
        }
    }
    return true;
}
//# sourceMappingURL=index.js.map