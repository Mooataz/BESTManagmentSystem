"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildBenchmarks = buildBenchmarks;
const utils_1 = require("@best/utils");
const worker_farm_1 = __importDefault(require("worker-farm"));
const build_benchmark_1 = require("./build-benchmark");
const DEFAULT_FARM_OPTS = {
    maxConcurrentWorkers: utils_1.isCI ? 2 : require('os').cpus().length,
    maxConcurrentCallsPerWorker: 1,
};
async function runInBand(benchmarks, projectConfig, globalConfig, buildLogStream) {
    const benchmarkResults = [];
    for (const benchmark of benchmarks) {
        const result = await (0, build_benchmark_1.buildBenchmark)(benchmark, projectConfig, globalConfig, buildLogStream);
        benchmarkResults.push(result);
    }
    return benchmarkResults;
}
function runInWorkers(benchmarks, projectConfig, globalConfig, buildLogStream) {
    const opts = {
        ...DEFAULT_FARM_OPTS,
        onChild: (child) => {
            child.on('message', (message) => {
                if (message.type === 'messager.onBenchmarkBuildStart') {
                    buildLogStream.onBenchmarkBuildStart(message.benchmarkPath);
                }
                else if (message.type === 'messager.log') {
                    buildLogStream.log(message.message);
                }
                else if (message.type === 'messager.onBenchmarkBuildEnd') {
                    buildLogStream.onBenchmarkBuildEnd(message.benchmarkPath);
                }
            });
        },
    };
    const workers = (0, worker_farm_1.default)(opts, require.resolve('./build-benchmark-worker'));
    const jobs = benchmarks.length;
    let jobsCompleted = 0;
    const benchBuild = [];
    return new Promise((resolve, reject) => {
        benchmarks.forEach((benchmark) => {
            const buildInfo = {
                benchmark,
                projectConfig,
                globalConfig,
            };
            workers(buildInfo, (err, result) => {
                if (err) {
                    return reject(err);
                }
                benchBuild.push(result);
                if (++jobsCompleted === jobs) {
                    worker_farm_1.default.end(workers);
                    resolve(benchBuild);
                }
            });
        });
    });
}
function buildBenchmarks(benchmarks, projectConfig, globalConfig, buildLogStream) {
    if (globalConfig.runInBand) {
        return runInBand(benchmarks, projectConfig, globalConfig, buildLogStream);
    }
    else {
        return runInWorkers(benchmarks, projectConfig, globalConfig, buildLogStream);
    }
}
//# sourceMappingURL=index.js.map