"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const runner_remote_1 = require("@best/runner-remote");
const shared_1 = require("@best/shared");
const types_1 = require("@best/types");
const { CONNECT_ERROR, DISCONNECT, ERROR, RECONNECT_FAILED } = shared_1.BEST_RPC;
const RPC_METHODS = [CONNECT_ERROR, DISCONNECT, ERROR, RECONNECT_FAILED];
class RemoteAgent extends events_1.EventEmitter {
    runner;
    socket;
    specs;
    state = types_1.AgentState.IDLE;
    token;
    uri;
    connected;
    constructor(socket, { uri, specs, token }) {
        super();
        this.socket = socket;
        this.connected = this.socket.connected;
        this.specs = specs;
        this.token = token;
        this.uri = uri;
        RPC_METHODS.forEach((methodName) => this.socket.on(methodName, this[methodName].bind(this)));
    }
    // -- Socket lifecycle ------------------------------------------------------------
    [DISCONNECT](reason) {
        if (this.connected) {
            console.log(`${this.getId()} - socket:disconnect`, reason);
            this.disconnectAgent(reason);
        }
    }
    [CONNECT_ERROR](reason) {
        console.log(`${this.getId()} - socket:connect_error`, reason);
        this.disconnectAgent(reason);
    }
    [ERROR](reason) {
        console.log(`${this.getId()} - socket:error`, reason);
        this.disconnectAgent(reason);
    }
    [RECONNECT_FAILED](reason) {
        console.log(`${this.getId()} - socket:reconnect_failed`, reason);
        this.disconnectAgent(reason);
    }
    // -- Specific Best RPC Commands ------------------------------------------------------------
    disconnectAgent(reason) {
        if (this.connected) {
            this.connected = false;
            this.socket.emit(shared_1.BEST_RPC.AGENT_REJECTION, reason);
            this.socket.disconnect(true);
            this.emit(shared_1.BEST_RPC.DISCONNECT, reason);
        }
    }
    getId() {
        return this.socket.id;
    }
    getSpecs() {
        return this.specs;
    }
    getState() {
        return {
            agentId: this.getId(),
            state: this.isIdle() ? types_1.AgentState.IDLE : types_1.AgentState.BUSY,
            specs: this.specs,
            uri: this.uri,
        };
    }
    getUri() {
        return this.uri;
    }
    interruptRunner() {
        if (this.isBusy() && this.runner) {
            this.runner.interruptRunner();
        }
    }
    isBusy() {
        return this.state === types_1.AgentState.BUSY;
    }
    isIdle() {
        return this.state === types_1.AgentState.IDLE;
    }
    async runBenchmarks(remoteClient, jobsToRun = remoteClient.getPendingBenchmarks()) {
        if (this.isIdle() && remoteClient.getPendingBenchmarks() > 0) {
            this.state = types_1.AgentState.BUSY;
            const iterator = Array.from(Array(jobsToRun), (x, index) => index + 1);
            const runnerConfig = {
                isHub: true,
                jobs: 1,
                options: {},
                specs: remoteClient.getSpecs(),
                uri: this.uri,
            };
            if (this.token) {
                runnerConfig.options.authToken = this.token;
            }
            try {
                for (const job of iterator) {
                    console.log(`[REMOTE_AGENT] Running job ${job} of ${jobsToRun}`);
                    const benchmarkBuild = await remoteClient.requestJob();
                    this.runner = new runner_remote_1.RunnerRemote([benchmarkBuild], remoteClient, runnerConfig);
                    const results = await this.runner.run();
                    remoteClient.sendResults(results);
                    console.log(`[REMOTE_AGENT_${this.getId()}] Completed job ${job} of ${jobsToRun}`);
                }
            }
            finally {
                this.state = types_1.AgentState.IDLE;
                this.runner = undefined;
            }
        }
    }
    toString() {
        return `[REMOTE_AGENT_${this.getId()}]`;
    }
}
exports.default = RemoteAgent;
//# sourceMappingURL=remote-agent.js.map