"use strict";
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lwc_1 = require("lwc");
const socket_1 = require("store/socket");
const shared_1 = require("@best/shared");
// eslint-disable-next-line no-undef
const host = window.location.origin;
const socketConfig = { path: '/frontend', query: { frontend: true } };
let ViewDashboard = (() => {
    let _classSuper = lwc_1.LightningElement;
    let _agents_decorators;
    let _agents_initializers = [];
    let _agents_extraInitializers = [];
    let _clients_decorators;
    let _clients_initializers = [];
    let _clients_extraInitializers = [];
    let _activeClients_decorators;
    let _activeClients_initializers = [];
    let _activeClients_extraInitializers = [];
    let _jobs_decorators;
    let _jobs_initializers = [];
    let _jobs_extraInitializers = [];
    return class ViewDashboard extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _agents_decorators = [lwc_1.track];
            _clients_decorators = [lwc_1.track];
            _activeClients_decorators = [lwc_1.track];
            _jobs_decorators = [lwc_1.track];
            __esDecorate(null, null, _agents_decorators, { kind: "field", name: "agents", static: false, private: false, access: { has: obj => "agents" in obj, get: obj => obj.agents, set: (obj, value) => { obj.agents = value; } }, metadata: _metadata }, _agents_initializers, _agents_extraInitializers);
            __esDecorate(null, null, _clients_decorators, { kind: "field", name: "clients", static: false, private: false, access: { has: obj => "clients" in obj, get: obj => obj.clients, set: (obj, value) => { obj.clients = value; } }, metadata: _metadata }, _clients_initializers, _clients_extraInitializers);
            __esDecorate(null, null, _activeClients_decorators, { kind: "field", name: "activeClients", static: false, private: false, access: { has: obj => "activeClients" in obj, get: obj => obj.activeClients, set: (obj, value) => { obj.activeClients = value; } }, metadata: _metadata }, _activeClients_initializers, _activeClients_extraInitializers);
            __esDecorate(null, null, _jobs_decorators, { kind: "field", name: "jobs", static: false, private: false, access: { has: obj => "jobs" in obj, get: obj => obj.jobs, set: (obj, value) => { obj.jobs = value; } }, metadata: _metadata }, _jobs_initializers, _jobs_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        agents = __runInitializers(this, _agents_initializers, []);
        clients = (__runInitializers(this, _agents_extraInitializers), __runInitializers(this, _clients_initializers, []));
        activeClients = (__runInitializers(this, _clients_extraInitializers), __runInitializers(this, _activeClients_initializers, []));
        jobs = (__runInitializers(this, _activeClients_extraInitializers), __runInitializers(this, _jobs_initializers, []));
        connectedCallback() {
            const socket = (0, socket_1.connect)(host, socketConfig);
            socket.on(shared_1.BEST_RPC.AGENT_STATE, this.onAgentState.bind(this));
            socket.on(shared_1.BEST_RPC.HUB_CONNECTED_AGENT, this.onConnectedAgent.bind(this));
            socket.on(shared_1.BEST_RPC.HUB_DISCONNECTED_AGENT, this.onDisconnectedAgent.bind(this));
            socket.on(shared_1.BEST_RPC.AGENT_CONNECTED_CLIENT, this.onConnectedClient.bind(this));
            socket.on(shared_1.BEST_RPC.AGENT_DISCONNECTED_CLIENT, this.onDisconnectedClient.bind(this));
            socket.on(shared_1.BEST_RPC.AGENT_QUEUED_CLIENT, this.onQueuedClient.bind(this));
            socket.on(shared_1.BEST_RPC.BENCHMARK_START, this.onBenchmarkStart.bind(this));
            socket.on(shared_1.BEST_RPC.BENCHMARK_UPDATE, this.onBenchmarkUpdate.bind(this));
            socket.on(shared_1.BEST_RPC.BENCHMARK_END, this.onBenchmarkEnd.bind(this));
        }
        onAgentState(state) {
            console.log(shared_1.BEST_RPC.AGENT_STATE, state);
            this.agents = state.connectedAgents;
            this.clients = state.connectedClients;
            state.activeClients.forEach(({ agentId, clientId }) => {
                this.setClientState('BUSY', clientId);
                this.setAgentState('BUSY', agentId);
            });
        }
        onConnectedAgent(newAgent) {
            const { agentId } = newAgent;
            console.log(shared_1.BEST_RPC.HUB_CONNECTED_AGENT, newAgent);
            if (!this.agents.find((agent) => agent.agentId === agentId)) {
                this.agents.push({ ...newAgent, state: newAgent.state || 'IDLE' });
            }
        }
        onDisconnectedAgent(removedAgent) {
            const { agentId } = removedAgent;
            console.log(shared_1.BEST_RPC.HUB_DISCONNECTED_AGENT, removedAgent);
            const index = this.agents.findIndex((agent) => agent.agentId === agentId);
            if (index > -1) {
                this.agents.splice(index, 1);
            }
            const jobIndex = this.jobs.findIndex((j) => j.agentId === agentId);
            if (jobIndex > -1) {
                this.jobs.splice(jobIndex, 1);
            }
        }
        onConnectedClient(newClient) {
            const { clientId } = newClient;
            console.log(shared_1.BEST_RPC.AGENT_CONNECTED_CLIENT, newClient);
            if (!this.clients.find((client) => client.clientId === clientId)) {
                this.clients.push({ ...newClient });
            }
        }
        onDisconnectedClient(clientId) {
            const pos = this.clients.findIndex((c) => c.id === clientId);
            this.clients.splice(pos, 1);
            const jobIndex = this.jobs.findIndex((j) => j.clientId === clientId);
            if (jobIndex > -1) {
                this.jobs.splice(jobIndex, 1);
            }
        }
        onQueuedClient(...args) {
            console.log(shared_1.BEST_RPC.AGENT_QUEUED_CLIENT, args);
        }
        onBenchmarkStart(bStart) {
            console.log(shared_1.BEST_RPC.BENCHMARK_START, bStart);
            const agent = this.agents.find((a) => a.agentId === bStart.agentId);
            const client = this.clients.find((c) => c.clientId === bStart.clientId);
            if (agent && client) {
                this.setClientState('BUSY', client.clientId);
                this.setAgentState('BUSY', agent.agentId);
            }
        }
        onBenchmarkEnd(bEnd) {
            console.log(shared_1.BEST_RPC.BENCHMARK_END, bEnd);
            const jobIndex = this.jobs.findIndex((j) => j.benchmarkId === bEnd.benchmarkId);
            const agent = this.agents.find((a) => a.agentId === bEnd.agentId);
            const client = this.clients.find((c) => c.clientId === bEnd.clientId);
            if (agent && client) {
                this.setClientState('IDLE', client.clientId);
                this.setAgentState('IDLE', agent.agentId);
            }
            if (jobIndex > -1) {
                this.jobs.splice(jobIndex, 1);
            }
        }
        onBenchmarkUpdate(update) {
            console.log(shared_1.BEST_RPC.BENCHMARK_UPDATE, update);
            const job = this.jobs.find((j) => j.benchmarkId === update.benchmarkId);
            if (!job) {
                this.jobs.push({
                    benchmarkId: update.benchmarkId,
                    clientId: update.clientId,
                    agentId: update.agentId,
                    executedTime: update.state.executedTime,
                    executedIterations: update.state.executedIterations,
                    iterations: update.opts.iterations,
                    maxDuration: update.opts.maxDuration,
                    minSampleCount: update.opts.minSampleCount,
                });
            }
            else {
                job.executedTime = update.state.executedTime;
                job.executedIterations = update.state.executedIterations;
            }
        }
        // STATE CHANGES
        setClientState(state, clientId) {
            const client = this.clients.find((c) => c.clientId === clientId);
            if (client) {
                client.state = state;
            }
        }
        setAgentState(state, agentId) {
            const agent = this.agents.find((c) => c.agentId === agentId);
            if (agent) {
                agent.state = state;
            }
        }
        // GETTERS
        get connectedClients() {
            return this.clients.length;
        }
        get connectedAgents() {
            return this.agents.length;
        }
        get normalizedAgents() {
            return this.agents.map((agent) => ({ ...agent }));
        }
        get normalizedClients() {
            return this.clients.map((client) => ({ ...client }));
        }
        get hasJobs() {
            return this.jobs.length > 0;
        }
        constructor() {
            super(...arguments);
            __runInitializers(this, _jobs_extraInitializers);
        }
    };
})();
exports.default = ViewDashboard;
//# sourceMappingURL=dashboard.js.map