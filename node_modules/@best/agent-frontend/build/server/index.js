"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveFrontend = serveFrontend;
exports.observeAgent = observeAgent;
const path_1 = __importDefault(require("path"));
const express_1 = __importDefault(require("express"));
const socket_io_1 = require("socket.io");
const shared_1 = require("@best/shared");
function serveFrontend(app) {
    const DIST_DIR = path_1.default.resolve(__dirname, '../../dist');
    app.use(express_1.default.static(DIST_DIR));
    app.get('*', (req, res) => res.sendFile(path_1.default.resolve(DIST_DIR, 'index.html')));
}
const FrontendSockets = new Set();
function forwardEvent(eventType, ...args) {
    for (const socket of FrontendSockets) {
        socket.emit.apply(socket, [eventType, ...args]);
    }
}
const { AGENT_CONNECTED_CLIENT, AGENT_DISCONNECTED_CLIENT, AGENT_QUEUED_CLIENT, BENCHMARK_END, BENCHMARK_START, BENCHMARK_UPDATE, HUB_CONNECTED_AGENT, HUB_DISCONNECTED_AGENT, } = shared_1.BEST_RPC;
const FORWARD_EVENTS = [
    AGENT_CONNECTED_CLIENT,
    AGENT_DISCONNECTED_CLIENT,
    AGENT_QUEUED_CLIENT,
    BENCHMARK_END,
    BENCHMARK_START,
    BENCHMARK_UPDATE,
    HUB_CONNECTED_AGENT,
    HUB_DISCONNECTED_AGENT,
];
function observeAgent(server, agent) {
    // Instanciate a new socketServer on a dedicated path
    const socketServer = new socket_io_1.Server(server, { path: '/frontend' });
    // Listen for the needed events on the agent
    FORWARD_EVENTS.forEach((event) => agent.on(event, forwardEvent.bind(null, event)));
    // Manage connections
    socketServer.on('connect', (socket) => {
        console.log(`[AGENT_FE] Adding Frontend socket ${socket.id} | active: ${FrontendSockets.size}`);
        socket.emit(shared_1.BEST_RPC.AGENT_STATE, agent.getState());
        FrontendSockets.add(socket);
        socket.on('disconnect', () => {
            FrontendSockets.delete(socket);
            console.log(`[AGENT_FE] Disconnecting Frontend socket ${socket.id} | remaining: ${FrontendSockets.size}`);
        });
    });
}
//# sourceMappingURL=index.js.map