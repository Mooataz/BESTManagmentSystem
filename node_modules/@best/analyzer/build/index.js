"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareSamples = void 0;
exports.analyzeBenchmarks = analyzeBenchmarks;
exports.computeSampleStats = computeSampleStats;
const constants_1 = require("./constants");
const stats_1 = require("./stats");
Object.defineProperty(exports, "compareSamples", { enumerable: true, get: function () { return stats_1.compare; } });
function computeSampleStats(arr, samplesQuantileThreshold) {
    if (samplesQuantileThreshold < 1) {
        const q = (0, stats_1.quantile)(arr, samplesQuantileThreshold);
        arr = arr.filter((v) => v <= q);
    }
    return {
        samples: arr,
        sampleSize: arr.length,
        samplesQuantileThreshold,
        mean: (0, stats_1.mean)(arr),
        median: (0, stats_1.median)(arr),
        variance: (0, stats_1.variance)(arr),
        medianAbsoluteDeviation: (0, stats_1.medianAbsoluteDeviation)(arr),
    };
}
// Given an iteration benchmark (whith nested benchmarks), collect its metrics
function collectResults(resultNode, collector, projectConfig) {
    const { name } = resultNode;
    let collectorNode = collector[name];
    if (!collectorNode) {
        const emptyMetrics = projectConfig.metrics.reduce((acc, key) => ({
            ...acc,
            [key]: [],
        }), {});
        collectorNode = collector[name] = emptyMetrics;
    }
    if (resultNode.aggregate > 0 && collectorNode.aggregate) {
        collectorNode.aggregate.push(resultNode.aggregate);
    }
    if (resultNode.type === 'benchmark') {
        const { metrics } = resultNode;
        Object.keys(metrics).reduce((collector, key) => {
            const bucket = collector[key];
            const value = metrics[key];
            if (bucket && value) {
                bucket.push(value);
            }
            return collector;
        }, collectorNode);
    }
    else {
        resultNode.nodes.forEach((node) => collectResults(node, collector, projectConfig));
    }
    return collector;
}
function createStatsStructure(node, collector) {
    if (node.type === 'benchmark') {
        const { name, type } = node;
        const metricStats = collector[name];
        const metrics = Object.keys(metricStats).reduce((metricReducer, metric) => {
            const stats = metricStats[metric];
            if (stats) {
                metricReducer[metric] = { stats };
            }
            return metricReducer;
        }, {});
        return { type, name, metrics };
    }
    else {
        const { name, type, nodes: children } = node;
        const nodes = children.map((childNode) => createStatsStructure(childNode, collector));
        return { type, name, nodes };
    }
}
async function analyzeBenchmarks(benchmarkResults) {
    return Promise.all(
    // For each benchmark file runned...
    benchmarkResults.map(async (benchmarkResult) => {
        const { results, benchmarkInfo: { benchmarkName }, projectConfig, } = benchmarkResult;
        const structure = results[0];
        // Collect the metrics for the nested benchmarks within
        const collector = results.reduce((reducer, node) => collectResults(node, reducer, projectConfig), {});
        // For each metric
        const benchmarkStats = Object.keys(collector).reduce((stats, benchmarkName) => {
            const benchmarkMetrics = collector[benchmarkName];
            stats[benchmarkName] = Object.keys(benchmarkMetrics).reduce((metricStats, metric) => {
                const metricResults = benchmarkMetrics[metric];
                if (Array.isArray(metricResults) && metricResults.length > 0) {
                    metricStats[metric] = computeSampleStats(metricResults, projectConfig.samplesQuantileThreshold);
                }
                return metricStats;
            }, {});
            return stats;
        }, {});
        const benchmarkStructure = createStatsStructure(structure, benchmarkStats);
        benchmarkResult.stats = {
            version: constants_1.VERSION,
            benchmarkName,
            results: benchmarkStructure.nodes,
        };
    }));
}
//# sourceMappingURL=index.js.map