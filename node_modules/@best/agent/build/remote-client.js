"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const path_1 = __importDefault(require("path"));
const shared_1 = require("@best/shared");
const types_1 = require("@best/types");
const benchmark_loader_1 = require("./utils/benchmark-loader");
var RemoteClientState;
(function (RemoteClientState) {
    RemoteClientState["IDLE"] = "IDLE";
    RemoteClientState["REQUESTING_JOB_INFO"] = "REQUESTING_JOB_INFO";
    RemoteClientState["REQUESTING_JOB_PAYLOAD"] = "REQUESTING_JOB_PAYLOAD";
})(RemoteClientState || (RemoteClientState = {}));
const { DISCONNECT, CONNECT_ERROR, ERROR, RECONNECT_FAILED, BENCHMARK_UPLOAD_RESPONSE } = shared_1.BEST_RPC;
const RPC_METHODS = [DISCONNECT, CONNECT_ERROR, ERROR, RECONNECT_FAILED, BENCHMARK_UPLOAD_RESPONSE];
class RemoteClient extends events_1.EventEmitter {
    socket;
    uploader;
    specs;
    connected;
    pendingBenchmarksToUpload;
    pendingResultsToSend = 0;
    state = RemoteClientState.IDLE;
    _requestJobSuccess = function () { };
    _requestJobError = function (err) {
        throw new Error(err);
    };
    debounce;
    constructor(socket, { specs, jobs }) {
        super();
        this.socket = socket;
        this.connected = this.socket.connected;
        this.specs = specs;
        this.pendingBenchmarksToUpload = jobs;
        RPC_METHODS.forEach((methodName) => this.socket.on(methodName, this[methodName].bind(this)));
    }
    // -- Socket lifecycle ------------------------------------------------------------
    [CONNECT_ERROR](reason) {
        console.log(`${this.getId()} - socket:connect_error`, reason);
        this.disconnectClient(reason);
    }
    [DISCONNECT](reason) {
        if (this.connected) {
            console.log(`${this.getId()} - socket:disconnect`, reason);
            this.disconnectClient(reason);
        }
    }
    [ERROR](reason) {
        console.log(`${this.getId()} - socket:error`, reason);
        this.disconnectClient(reason);
    }
    [RECONNECT_FAILED](reason) {
        console.log(`${this.getId()} - socket:reconnect_failed`, reason);
        this.disconnectClient(reason);
    }
    // -- Specific Best RPC Commands ------------------------------------------------------------
    async [BENCHMARK_UPLOAD_RESPONSE](benchmarkConfig, emitContinuationForUpload) {
        if (this.state !== RemoteClientState.REQUESTING_JOB_INFO) {
            this.disconnectClient('Client should not send jobs at this point.');
            this._requestJobError('Unexpected upload response');
        }
        console.log(`[AGENT_REMOTE_CLIENT] Receiving benchmark ${benchmarkConfig.benchmarkSignature} from socket ${this.socket.id}`);
        const { benchmarkEntry, benchmarkName, benchmarkSignature } = benchmarkConfig;
        const uploader = this.getUploader();
        this.state = RemoteClientState.REQUESTING_JOB_PAYLOAD;
        emitContinuationForUpload(benchmarkSignature); // This is an ACK, telling the client that is ok to send the file now
        try {
            // Retrieve an uncompress the benchmark bundle
            const tarFile = await uploader.load(benchmarkEntry);
            /*
             * Unfortunately, because of the way Best was designed, the hub
             * does a lot of unnecessary extracting and compressing of files,
             * when it already has the `tar` it needs to send to the agent.
             *
             * Because of that, the more tests Best has to run, the slower things
             * will be, and sometimes Best will even crash.
             *
             * The following is a band-aid fix until a more major refactoring \
             * rearchitecting of Best is done.
             *
             * Ref: https://github.com/salesforce/best/commit/889191e84607afd93b206d64c68649b5c0905952
             */
            if (benchmarkConfig.isHub) {
                await (0, benchmark_loader_1.extractBenchmarkTarFile)(tarFile);
            }
            // Modify the benchmark bundle to point to the new files
            const uploadDir = path_1.default.dirname(tarFile);
            benchmarkConfig.benchmarkRemoteEntry = path_1.default.join(uploadDir, `${benchmarkName}.html`);
            benchmarkConfig.benchmarkRemoteFolder = uploadDir;
            console.log(`[AGENT_REMOTE_CLIENT] Completed upload for benchmark ${benchmarkConfig.benchmarkSignature} from socket ${this.socket.id}`);
            this.state = RemoteClientState.IDLE;
            this.pendingBenchmarksToUpload -= 1;
            this.pendingResultsToSend += 1;
            this._requestJobSuccess(benchmarkConfig);
            // Notify upload updates
            this.emit(shared_1.BEST_RPC.REMOTE_CLIENT_UPLOAD_COMPLETED);
        }
        catch (err) {
            this.disconnectClient(err.message);
            this._requestJobError(err);
        }
        finally {
            this.state = RemoteClientState.IDLE;
        }
    }
    // -- Private
    getUploader() {
        if (!this.uploader) {
            const uploader = (0, benchmark_loader_1.getUploaderInstance)(this.socket);
            uploader.on('stream', ({ wrote, size }) => {
                console.log(`  :: [ARC-${this.socket.id}] loading benchmark (${wrote} / ${size})`);
            });
            this.uploader = uploader;
        }
        return this.uploader;
    }
    // -- RunnerStream methods ----------------------------------------------------------
    finish() {
        console.log(`[AGENT_REMOTE_CLIENT] finishingRunner`);
    }
    init() {
        console.log(`[AGENT_REMOTE_CLIENT] startingRunner`);
    }
    log(message) {
        if (this.socket.connected) {
            this.socket.emit(shared_1.BEST_RPC.BENCHMARK_LOG, message);
        }
    }
    onBenchmarkEnd(benchmarkSignature) {
        console.log(`[AGENT_REMOTE_CLIENT] benchmarkEnd(${benchmarkSignature})`);
        if (this.socket.connected) {
            this.socket.emit(shared_1.BEST_RPC.BENCHMARK_END, benchmarkSignature);
            this.emit(shared_1.BEST_RPC.BENCHMARK_END, benchmarkSignature);
            clearTimeout(this.debounce);
            this.debounce = undefined;
        }
    }
    onBenchmarkError(benchmarkSignature) {
        if (this.socket.connected) {
            this.socket.emit(shared_1.BEST_RPC.BENCHMARK_ERROR, benchmarkSignature);
            this.emit(shared_1.BEST_RPC.BENCHMARK_ERROR, benchmarkSignature);
        }
    }
    onBenchmarkStart(benchmarkSignature) {
        if (this.socket.connected) {
            console.log(`[AGENT_REMOTE_CLIENT] benchmarkStart(${benchmarkSignature})`);
            this.socket.emit(shared_1.BEST_RPC.BENCHMARK_START, benchmarkSignature);
            this.emit(shared_1.BEST_RPC.BENCHMARK_START, benchmarkSignature);
        }
    }
    updateBenchmarkProgress(benchmarkSignature, state, opts) {
        if (!this.debounce && this.socket.connected) {
            this.debounce = setTimeout(() => {
                this.debounce = undefined;
                if (this.socket.connected) {
                    console.log(`[AGENT_REMOTE_CLIENT] benchmarkProgress(${benchmarkSignature}) | iterations: ${state.executedIterations}`);
                    this.socket.emit(shared_1.BEST_RPC.BENCHMARK_UPDATE, benchmarkSignature, state, opts);
                    this.emit(shared_1.BEST_RPC.BENCHMARK_UPDATE, benchmarkSignature, state, opts);
                }
            }, 1000);
        }
    }
    // -- Imperative methods ------------------------------------------------------------
    disconnectClient(reason) {
        if (this.connected) {
            this.connected = false;
            this.pendingBenchmarksToUpload = -1;
            this.socket.emit(shared_1.BEST_RPC.AGENT_REJECTION, reason);
            this.socket.disconnect(true);
            this.emit(shared_1.BEST_RPC.DISCONNECT, reason);
        }
    }
    getId() {
        return `REMOTE_CLIENT_${this.socket.id}`;
    }
    getPendingBenchmarks() {
        return this.pendingBenchmarksToUpload;
    }
    getSpecs() {
        return this.specs;
    }
    getState() {
        return {
            clientId: this.toString(),
            specs: this.specs,
            jobs: this.getPendingBenchmarks(),
            state: this.isIdle() ? types_1.AgentState.IDLE : types_1.AgentState.BUSY,
        };
    }
    getStatusInfo() {
        return `remining jobs: ${this.pendingBenchmarksToUpload} | specs: ${this.specs} | state: ${this.state}`;
    }
    isBusy() {
        return !this.isIdle();
    }
    isIdle() {
        return this.state === RemoteClientState.IDLE;
    }
    requestJob() {
        if (this.isIdle()) {
            return new Promise((resolve, reject) => {
                this.state = RemoteClientState.REQUESTING_JOB_INFO;
                this.socket.emit(shared_1.BEST_RPC.BENCHMARK_UPLOAD_REQUEST);
                this._requestJobSuccess = resolve;
                this._requestJobError = reject;
            });
        }
        else {
            return Promise.reject(`RemoteClient is busy`);
        }
    }
    sendResults(results) {
        this.pendingResultsToSend -= 1;
        console.log(`[AGENT_REMOTE_CLIENT] Sending Results | pending: ${this.pendingResultsToSend}`);
        this.socket.emit(shared_1.BEST_RPC.BENCHMARK_RESULTS, results);
        if (this.pendingBenchmarksToUpload === 0 && this.pendingResultsToSend === 0) {
            this.emit(shared_1.BEST_RPC.REMOTE_CLIENT_EMPTY_QUEUE);
        }
    }
    toString() {
        return this.getId();
    }
}
exports.default = RemoteClient;
//# sourceMappingURL=remote-client.js.map