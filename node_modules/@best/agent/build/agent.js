"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteClient = exports.Agent = void 0;
const socket_io_1 = require("socket.io");
const types_1 = require("@best/types");
const shared_1 = require("@best/shared");
const runner_1 = require("@best/runner");
const utils_1 = require("@best/utils");
const validate_1 = require("./utils/validate");
const create_bundle_config_1 = require("./utils/create-bundle-config");
const remote_client_1 = __importDefault(require("./remote-client"));
exports.RemoteClient = remote_client_1.default;
const utils_2 = require("@best/utils");
const events_1 = require("events");
const remote_hub_1 = __importDefault(require("./remote-hub"));
class Agent extends events_1.EventEmitter {
    id;
    uri;
    socketServer;
    state;
    specs = [];
    agentConfig;
    remoteHubConfig;
    connectedClients = new Set();
    activeClient;
    interruption;
    constructor(server, agentConfig, remoteHubConfig) {
        super();
        (0, runner_1.validateRunner)(agentConfig.runner);
        this.uri = agentConfig.uri;
        this.id = agentConfig.name || `Agent[${Date.now()}]`;
        this.agentConfig = agentConfig;
        this.remoteHubConfig = remoteHubConfig;
        this.socketServer = new socket_io_1.Server(server, { path: '/best' });
        this.socketServer.on('connect', this.onClientConnect.bind(this));
        this.state = types_1.AgentState.IDLE;
        this.loadRunnerSpecs();
        if (this.remoteHubConfig.uri) {
            this.once('ready', () => {
                const remoteHub = this.setupNewHub(this.remoteHubConfig, this.specs, this.agentConfig);
                remoteHub.connectToHub();
            });
        }
    }
    async loadRunnerSpecs() {
        this.specs = await (0, runner_1.getBrowserSpecs)(this.agentConfig.runner);
        console.log(`[AGENT] Available specs: ${JSON.stringify(this.specs)}`);
        this.emit('ready');
    }
    onClientConnect(socketClient) {
        const query = socketClient.handshake.query;
        const config = (0, utils_1.normalizeClientConfig)(query);
        const invalidConfig = (0, validate_1.validateConfig)(config, this.agentConfig, this.specs, socketClient.id);
        if (invalidConfig) {
            socketClient.emit(shared_1.BEST_RPC.AGENT_REJECTION, invalidConfig);
            return socketClient.disconnect(true);
        }
        const remoteClient = this.setupNewClient(socketClient, config);
        console.log(`[AGENT] Connected clients: ${this.connectedClients.size} | state: ${this.state} | activePending: ${this.activeClient && this.activeClient.getPendingBenchmarks()}`);
        if (this.idleState) {
            this.runBenchmark(remoteClient);
        }
        else {
            remoteClient.log(`Client enqueued. Waiting for the agent to be free...`);
            this.emit(shared_1.BEST_RPC.AGENT_QUEUED_CLIENT, {
                clientId: remoteClient.getId(),
                jobs: config.jobs,
                specs: config.specs,
            });
        }
    }
    async runBenchmark(remoteClient) {
        if (this.idleState) {
            this.state = types_1.AgentState.BUSY;
            this.activeClient = remoteClient;
            try {
                console.log(`[AGENT] Requesting benchmark from RemoteClient ${remoteClient.getId()}`);
                const benchmarkBuild = await remoteClient.requestJob();
                const bundleConfig = (0, create_bundle_config_1.createBundleConfig)(benchmarkBuild, this.agentConfig);
                console.log(`[AGENT] Running benchmark ${benchmarkBuild.benchmarkSignature} from RemoteClient ${remoteClient.getId()}`);
                this.interruption = new utils_2.RunnerInterruption(benchmarkBuild.benchmarkSignature);
                const results = await (0, runner_1.runBenchmarks)(bundleConfig, remoteClient, this.interruption);
                console.log(`[AGENT] Completed benchmark ${benchmarkBuild.benchmarkSignature} from RemoteClient ${remoteClient.getId()}`);
                remoteClient.sendResults(results);
            }
            catch (err) {
                console.log(`[AGENT] Error running benchmark for remote client ${remoteClient.getId()}`);
                console.log(err);
                remoteClient.disconnectClient(`Error running benchmark: ${err.message}`); // make sure we disconnect the agent
            }
            finally {
                this.state = types_1.AgentState.IDLE;
                this.interruption = undefined;
                queueMicrotask(() => this.runQueuedBenchmarks());
            }
        }
        else {
            console.log('[AGENT] Benchmark already running...');
        }
    }
    runQueuedBenchmarks() {
        if (this.idleState) {
            console.log('[AGENT] Checking for queued agents and tasks...');
            if (this.activeClient && this.activeClient.getPendingBenchmarks()) {
                console.log(`[AGENT] Active Client "${this.activeClient.getId()}" has still ${this.activeClient.getPendingBenchmarks()} pending`);
                this.runBenchmark(this.activeClient);
            }
            else {
                // Note that there might be some clients with no jobs still connected (we give them some time to disconnect)
                // So to avoid race conditions we check for remaining jobs, rather that just check for an arbitrary client on the queue
                const remoteClient = Array.from(this.connectedClients).find((client) => client.getPendingBenchmarks() > 0);
                if (remoteClient) {
                    console.log(`[AGENT] Client "${remoteClient.getId()}" has ${remoteClient.getPendingBenchmarks()} to run`);
                    this.runBenchmark(remoteClient);
                }
                else {
                    console.log('[AGENT] No more jobs to run at the moment');
                }
            }
        }
        else {
            console.log(`[AGENT] Busy, running ${this.activeClient.getId()}`);
        }
    }
    get idleState() {
        return this.state === types_1.AgentState.IDLE;
    }
    getStateInfo() {
        return `
            |> state: ${this.idleState}
            |> clients: ${this.connectedClients.size}
            |> activeClient: ${this.activeClient && this.activeClient.getId()}
        `;
    }
    setupNewHub(remoteHubConfig, specs, agentConfig) {
        const remoteHub = new remote_hub_1.default(remoteHubConfig, specs, agentConfig);
        remoteHub.on(shared_1.BEST_RPC.AGENT_CONNECTED_HUB, (hubUri) => this.emit(shared_1.BEST_RPC.AGENT_CONNECTED_HUB, hubUri));
        remoteHub.on(shared_1.BEST_RPC.AGENT_DISCONNECTED_HUB, (hubUri) => this.emit(shared_1.BEST_RPC.AGENT_DISCONNECTED_HUB, hubUri));
        return remoteHub;
    }
    setupNewClient(socketClient, clientConfig) {
        // Create and new RemoteClient and add it to the pool
        const remoteClient = new remote_client_1.default(socketClient, clientConfig);
        this.connectedClients.add(remoteClient);
        console.log(`[AGENT] New client ${remoteClient.getId()} connected. Jobs requested ${clientConfig.jobs} | specs: ${JSON.stringify(clientConfig.specs)}`);
        this.emit(shared_1.BEST_RPC.AGENT_CONNECTED_CLIENT, { clientId: remoteClient.getId(), jobs: clientConfig.jobs });
        // Make sure we remove it from an agent's perspective if the client is disconnected
        remoteClient.on(shared_1.BEST_RPC.DISCONNECT, () => {
            console.log(`[AGENT] Disconnected client ${remoteClient.getId()}`);
            this.emit(shared_1.BEST_RPC.AGENT_DISCONNECTED_CLIENT, remoteClient.getId());
            this.connectedClients.delete(remoteClient);
            if (this.activeClient === remoteClient) {
                this.activeClient = undefined;
                if (this.interruption) {
                    console.log(`[AGENT] Halting benchmark runner`);
                    this.interruption.requestInterruption();
                }
            }
            /*
             * Once the disconnect happens, the agent is now able to
             * take on new tasks, hence, mark its state as "idle".
             */
            this.state = types_1.AgentState.IDLE;
        });
        // Forward events from the Client to the Agent
        remoteClient.on(shared_1.BEST_RPC.BENCHMARK_START, (benchmarkId) => {
            this.emit(shared_1.BEST_RPC.BENCHMARK_START, { agentId: this.id, clientId: remoteClient.getId(), benchmarkId });
        });
        remoteClient.on(shared_1.BEST_RPC.BENCHMARK_END, (benchmarkId) => {
            this.emit(shared_1.BEST_RPC.BENCHMARK_END, { agentId: this.id, clientId: remoteClient.getId(), benchmarkId });
        });
        remoteClient.on(shared_1.BEST_RPC.BENCHMARK_UPDATE, (benchmarkId, state, opts) => {
            this.emit(shared_1.BEST_RPC.BENCHMARK_UPDATE, {
                agentId: this.id,
                clientId: remoteClient.getId(),
                benchmarkId,
                state,
                opts,
            });
        });
        // If we are done with the job, make sure after a short time the client gets removed
        remoteClient.on(shared_1.BEST_RPC.REMOTE_CLIENT_EMPTY_QUEUE, () => {
            setTimeout(() => {
                if (this.connectedClients.has(remoteClient)) {
                    console.log(`[AGENT] Force client disconnect (${remoteClient.getId()}): With no more jobs to run an agent must disconnect`);
                    remoteClient.disconnectClient(`Forced disconnect: With no more jobs client should have disconnected`);
                }
            }, 10000);
        });
        return remoteClient;
    }
    getState() {
        const connectedClients = Array.from(this.connectedClients).map((client) => client.getState());
        const activeClients = this.activeClient ? [{ agentId: this.id, clientId: this.activeClient.getId() }] : [];
        return {
            connectedClients,
            connectedAgents: [
                {
                    agentId: this.id,
                    state: this.idleState ? types_1.AgentState.IDLE : types_1.AgentState.BUSY,
                    specs: this.specs,
                    uri: this.uri,
                },
            ],
            activeClients,
        };
    }
}
exports.Agent = Agent;
//# sourceMappingURL=agent.js.map