"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateComparisonSummary = generateComparisonSummary;
exports.generateComparisonComment = generateComparisonComment;
exports.generatePercentages = generatePercentages;
const json2md_1 = __importDefault(require("json2md"));
function padding(n) {
    return n > 0
        ? Array.apply(null, Array((n - 1) * 3))
            .map(() => ' ')
            .join('') + '└─ '
        : '';
}
function generateMarkdownFromGroupedTables(tables) {
    const flattenedTables = Object.keys(tables).reduce((groups, projectName) => {
        groups.push({ h2: `*${projectName}*` });
        groups.push(...tables[projectName]);
        return groups;
    }, []);
    return (0, json2md_1.default)(flattenedTables);
}
function generateRow(name, metrics, includeEmojiTrend) {
    const baseStats = metrics.baseStats;
    const targetStats = metrics.targetStats;
    const samplesComparison = metrics.samplesComparison;
    const percentage = (Math.abs(baseStats.median - targetStats.median) / baseStats.median) * 100;
    const relativeTrend = targetStats.median - baseStats.median;
    const sign = Math.sign(relativeTrend) === 1 ? '+' : '';
    const comparisonEmoji = samplesComparison === 0 ? '👌' : samplesComparison === 1 ? '👎' : '👍';
    return [
        name,
        `${baseStats.median.toFixed(2)} (± ${baseStats.medianAbsoluteDeviation.toFixed(2)}ms)`,
        `${targetStats.median.toFixed(2)} (± ${targetStats.medianAbsoluteDeviation.toFixed(2)}ms)`,
        sign +
            relativeTrend.toFixed(1) +
            'ms (' +
            percentage.toFixed(1) +
            '%)' +
            (includeEmojiTrend ? ` ${comparisonEmoji}` : ''),
    ];
}
function generateRowsFromComparison(stats, handler, name = '', initialRows = []) {
    if (stats.type === 'project' || stats.type === 'group') {
        return stats.comparisons.reduce((rows, node) => {
            if (node.type === 'project' || node.type === 'group') {
                return generateRowsFromComparison(node, handler, node.name, rows);
            }
            else if (node.type === 'benchmark') {
                rows.push(...handler(node, name));
            }
            return rows;
        }, initialRows);
    }
    else {
        return initialRows;
    }
}
function significantlyChangedRows(stats, threshold, name = '', initialRows = { improved: [], regressed: [] }) {
    const highThreshold = Math.abs(threshold); // handle whether the threshold is positive or negative
    const lowThreshold = -1 * highThreshold;
    if (stats.type === 'project' || stats.type === 'group') {
        return stats.comparisons.reduce((rows, node) => {
            if (node.type === 'project' || node.type === 'group') {
                return significantlyChangedRows(node, threshold, node.name, rows);
            }
            else if (node.type === 'benchmark') {
                // for the significantly changed summary, we only check for aggregate
                const metrics = node.metrics.aggregate;
                if (metrics) {
                    const { baseStats, targetStats, samplesComparison } = metrics;
                    if (samplesComparison !== 0 && baseStats.median > 1 && targetStats.median > 1) {
                        // ensures passes Mann-Whiteney U test and results are more than 1ms
                        const percentage = (Math.abs(baseStats.median - targetStats.median) / baseStats.median) * 100;
                        const relativeTrend = targetStats.median - baseStats.median;
                        const relativePercentage = Math.sign(relativeTrend) * percentage;
                        const row = generateRow(`${name}/${node.name}`, metrics, false);
                        if (relativePercentage < lowThreshold) {
                            // less than a negative is GOOD (things got faster)
                            rows.improved.push(row);
                        }
                        else if (relativePercentage > highThreshold) {
                            // more than a positive is WORSE (things got slower)
                            rows.regressed.push(row);
                        }
                    }
                }
            }
            return rows;
        }, initialRows);
    }
    else {
        return initialRows;
    }
}
function generateAllRows(stats) {
    return generateRowsFromComparison(stats, (node, parentName) => {
        const rows = [];
        const emptyFields = Array.apply(null, Array(3)).map(() => '-');
        rows.push([`${parentName}/${node.name}`, ...emptyFields]);
        Object.keys(node.metrics).forEach((metric) => {
            const metrics = node.metrics[metric];
            if (metrics) {
                rows.push(generateRow(padding(1) + metric, metrics, true));
            }
        });
        return rows;
    });
}
function generateCommentWithTables(result, handler) {
    const { baseCommit, targetCommit, comparisons } = result;
    const grouped = comparisons.reduce((tables, node) => {
        if (node.type === 'project' || node.type === 'group') {
            const markdownTables = handler(node, baseCommit, targetCommit);
            if (markdownTables.length) {
                return {
                    ...tables,
                    [node.name]: markdownTables,
                };
            }
            return tables;
        }
        return tables;
    }, {});
    return generateMarkdownFromGroupedTables(grouped);
}
function generateComparisonSummary(result, threshold) {
    return generateCommentWithTables(result, (node, base, target) => {
        const changes = significantlyChangedRows(node, threshold);
        const tables = [];
        if (changes.improved.length) {
            tables.push({
                table: {
                    headers: [`✅ Improvements`, `base (\`${base}\`)`, `target (\`${target}\`)`, 'trend'],
                    rows: changes.improved,
                },
            });
        }
        if (changes.regressed.length) {
            tables.push({
                table: {
                    headers: [`❌ Regressions`, `base (\`${base}\`)`, `target (\`${target}\`)`, 'trend'],
                    rows: changes.regressed,
                },
            });
        }
        return tables;
    });
}
function generateAllRowsTable(baseCommit, targetCommit, stats) {
    const { name: benchmarkName } = stats;
    const mdName = benchmarkName.replace('.benchmark', '');
    return {
        table: {
            headers: [`${mdName}`, `base (\`${baseCommit}\`)`, `target (\`${targetCommit}\`)`, 'trend'],
            rows: generateAllRows(stats),
        },
    };
}
function generateComparisonComment(result) {
    const tablesMarkdown = generateCommentWithTables(result, (node, base, target) => {
        const tables = node.comparisons.map((child) => {
            return generateAllRowsTable(base, target, child);
        });
        return tables;
    });
    return `# Full Results\n\n${tablesMarkdown}`;
}
// this takes all the results and recursively goes through them
// then it creates a flat list of all of the percentages of change
function generatePercentages(stats) {
    return generateRowsFromComparison(stats, (node, _parentName) => {
        const rows = [];
        Object.keys(node.metrics).map((metricName) => {
            const metrics = node.metrics[metricName];
            if (metrics) {
                const { baseStats, targetStats, samplesComparison } = metrics;
                const baseMed = baseStats.median;
                const targetMed = targetStats.median;
                const percentage = Math.abs(((baseMed - targetMed) / baseMed) * 100);
                const relativeTrend = targetMed - baseMed;
                // ensures passes Mann-Whiteney U test and results are more than 1ms
                if (samplesComparison !== 0 && baseMed > 1 && targetMed > 1) {
                    rows.push(Math.sign(relativeTrend) * percentage);
                }
                else {
                    rows.push(0); // otherwise we count it as zero
                }
            }
        });
        return rows;
    });
}
//# sourceMappingURL=analyze.js.map