"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GithubApplicationFactory = void 0;
exports.updateLatestRelease = updateLatestRelease;
exports.beginBenchmarkComparisonCheck = beginBenchmarkComparisonCheck;
exports.failedBenchmarkComparisonCheck = failedBenchmarkComparisonCheck;
exports.completeBenchmarkComparisonCheck = completeBenchmarkComparisonCheck;
const utils_1 = require("@best/utils");
const api_db_1 = require("@best/api-db");
const git_app_1 = __importDefault(require("./git-app"));
exports.GithubApplicationFactory = git_app_1.default;
const analyze_1 = require("./analyze");
const PULL_REQUEST_URL = process.env.PULL_REQUEST;
function calculateAverageChange(result) {
    const flattenedValues = result.comparisons.reduce((all, node) => {
        return [...all, ...(0, analyze_1.generatePercentages)(node)];
    }, []);
    if (flattenedValues.length === 0) {
        return 0;
    }
    const sum = flattenedValues.reduce((previous, current) => (current += previous));
    const avg = sum / flattenedValues.length;
    return avg;
}
async function updateLatestRelease(projectNames, globalConfig) {
    try {
        const { gitInfo: { repo: { repo, owner }, }, } = globalConfig;
        const db = (0, api_db_1.loadDbFromConfig)(globalConfig);
        await db.migrate();
        const app = (0, git_app_1.default)();
        const gitHubInstallation = await app.authenticateAsAppAndInstallation({ repo, owner });
        const results = await gitHubInstallation.repos.listReleases({ repo, owner });
        if (results.data.length > 0) {
            const latestRelease = results.data[0];
            await Promise.all(projectNames.map(async (name) => {
                return db.updateLastRelease(name, latestRelease.created_at);
            }));
        }
    }
    catch (_err) {
        return false;
    }
    return true;
}
async function beginBenchmarkComparisonCheck(targetCommit, { gitInfo }) {
    if (!utils_1.isCI) {
        console.log('[NOT A CI] - The output will not be pushed.\n');
        return {};
    }
    const { repo: { repo, owner }, } = gitInfo;
    const app = (0, git_app_1.default)();
    const gitHubInstallation = await app.authenticateAsAppAndInstallation({ repo, owner });
    const result = await gitHubInstallation.checks.create({
        owner,
        repo,
        name: 'best',
        head_sha: targetCommit,
        status: 'in_progress',
    });
    const check = result.data;
    return { check, gitHubInstallation };
}
async function failedBenchmarkComparisonCheck(gitHubInstallation, check, error, globalConfig) {
    const { repo: { repo, owner }, } = globalConfig.gitInfo;
    const now = new Date().toISOString();
    const failureComment = 'Best failed with the following error:\n\n```' + error + '```';
    await gitHubInstallation.checks.update({
        owner,
        repo,
        check_run_id: check.id,
        completed_at: now,
        conclusion: 'failure',
        output: {
            title: 'Best Performance',
            summary: failureComment,
        },
    });
}
async function completeBenchmarkComparisonCheck(gitHubInstallation, check, comparison, globalConfig) {
    const { repo: { repo, owner }, } = globalConfig.gitInfo;
    const comparisonComment = (0, analyze_1.generateComparisonComment)(comparison);
    const comparisonSummary = (0, analyze_1.generateComparisonSummary)(comparison, globalConfig.commentThreshold);
    const now = new Date().toISOString();
    const { baseCommit, targetCommit } = comparison;
    const summary = `Base commit: \`${baseCommit}\` | Target commit: \`${targetCommit}\`\n\n${comparisonSummary}`;
    await gitHubInstallation.checks.update({
        owner,
        repo,
        check_run_id: check.id,
        completed_at: now,
        conclusion: 'success',
        output: {
            title: 'Best Summary',
            summary,
            text: comparisonComment,
        },
    });
    const averageChange = calculateAverageChange(comparison);
    const highThreshold = Math.abs(globalConfig.commentThreshold); // handle whether the threshold is positive or negative
    const lowThreshold = -1 * highThreshold;
    const significantlyImproved = averageChange < lowThreshold; // less than a negative is GOOD (things got faster)
    const significantlyRegressed = averageChange > highThreshold; // more than a positive is WORSE (things got slower)
    if ((significantlyRegressed || significantlyImproved) && PULL_REQUEST_URL !== undefined) {
        const prId = PULL_REQUEST_URL.split('/').pop();
        const pullRequestId = parseInt(prId, 10);
        let comment;
        if (significantlyRegressed) {
            comment = `# âš  Performance Regression\n\nBest has detected that there is a \`${Math.abs(averageChange).toFixed(1)}%\` performance regression across your benchmarks.\n\nPlease [click here](${check.html_url}) to see more details.`;
        }
        else {
            comment = `# ðŸ¥³ Performance Improvement\n\nBest has detected that there is a \`${Math.abs(averageChange).toFixed(1)}%\` performance improvement across your benchmarks.\n\nPlease [click here](${check.html_url}) to see more details.`;
        }
        if (comparisonSummary.length) {
            comment += `<details><summary>Click to view significantly changed benchmarks</summary>\n\n${comparisonSummary}</details>`;
        }
        await gitHubInstallation.issues.createComment({
            owner,
            repo,
            issue_number: pullRequestId,
            body: comment,
        });
    }
}
//# sourceMappingURL=index.js.map