"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBenchmarks = runBenchmarks;
exports.getBrowserSpecs = getBrowserSpecs;
exports.validateRunner = validateRunner;
const utils_1 = require("@best/utils");
async function runBenchmarksBundle(benchmarkBuild, runnerLogStream, interruption) {
    const { projectConfig, globalConfig, benchmarkBuilds } = benchmarkBuild;
    const { benchmarkRunner, benchmarkRunnerConfig } = projectConfig;
    if (!benchmarkRunnerConfig.specs) {
        throw new Error('You must provide specifications for the runner in your best config.');
    }
    const RunnerCtor = loadRunnerModule(benchmarkRunner);
    // If the runner is going to run locally, check the specification now
    // Note that we avoid delegating the spec matching to the runner in case it does not implements it
    if (!RunnerCtor.isRemote) {
        const runnerSpecs = await RunnerCtor.getBrowserSpecs();
        if (!(0, utils_1.matchSpecs)(benchmarkRunnerConfig.specs, runnerSpecs)) {
            throw new Error(`Specs: ${JSON.stringify(benchmarkRunnerConfig.specs)} do not match any avaible on the runner`);
        }
    }
    const runnerInstance = new RunnerCtor(projectConfig.benchmarkRunnerConfig);
    return runnerInstance.run(benchmarkBuilds, projectConfig, globalConfig, runnerLogStream, interruption);
}
function loadRunnerModule(benchmarkRunner) {
    try {
        const RunnerModule = require(benchmarkRunner);
        return RunnerModule.Runner || RunnerModule.default || RunnerModule;
    }
    catch (_e) {
        throw new Error(`Runner "${benchmarkRunner}" not found.`);
    }
}
async function runBenchmarks(benchmarksBuilds, messager, interruption) {
    const results = [];
    for (const benchmarkBundle of benchmarksBuilds) {
        const benchmarkResults = await runBenchmarksBundle(benchmarkBundle, messager, interruption);
        results.push(...benchmarkResults);
    }
    return results;
}
async function getBrowserSpecs(runner) {
    const benchmarkRunner = typeof runner === 'string' ? runner : runner.projectConfig.benchmarkRunner;
    const RunnerModule = loadRunnerModule(benchmarkRunner);
    return RunnerModule.getBrowserSpecs();
}
function validateRunner(runner) {
    loadRunnerModule(runner);
}
//# sourceMappingURL=index.js.map