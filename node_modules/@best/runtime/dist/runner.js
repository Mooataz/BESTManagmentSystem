/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
import { getBenchmarkRootNode } from './state';
import { runBenchmarkIteration } from './run_iteration';
import { normalizeResults } from './results';
import { validateState } from './utils/validate';
function collectNodeResults(node) {
    const { name, aggregate, startedAt, run, children } = node;
    const type = node.type;
    const resultNode = { type, name, aggregate, startedAt };
    if (run) {
        resultNode.aggregate = run.aggregate;
        resultNode.metrics = run.metrics;
    }
    else if (children) {
        resultNode.nodes = children.map((c) => collectNodeResults(c));
    }
    return resultNode;
}
async function runIterations(config) {
    if (config.executedTime < config.maxDuration || config.executedIterations < config.minSampleCount) {
        const { useMacroTaskAfterBenchmark } = config;
        const benchmark = await runBenchmarkIteration(getBenchmarkRootNode(), { useMacroTaskAfterBenchmark });
        const results = collectNodeResults(benchmark);
        config.results.push(results);
        config.executedTime += benchmark.aggregate;
        config.executedIterations += 1;
        if (!config.iterateOnClient) {
            return config;
        }
        return runIterations(config);
    }
    return config;
}
export async function runBenchmark(benchmarkState) {
    validateState(benchmarkState);
    if (benchmarkState.benchmarkDefinitionError) {
        throw benchmarkState.benchmarkDefinitionError;
    }
    benchmarkState.results = [];
    await runIterations(benchmarkState);
    return normalizeResults(benchmarkState);
}
//# sourceMappingURL=runner.js.map