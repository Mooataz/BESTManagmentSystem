"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConfigPathByTraversing = resolveConfigPathByTraversing;
exports.resolveConfigPath = resolveConfigPath;
exports.readConfigAndSetRootDir = readConfigAndSetRootDir;
exports.ensureNoDuplicateConfigs = ensureNoDuplicateConfigs;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
function isFile(filePath) {
    return fs_1.default.existsSync(filePath) && !fs_1.default.lstatSync(filePath).isDirectory();
}
function resolveConfigPathByTraversing(pathToResolve, initialPath, cwd) {
    const bestConfig = path_1.default.resolve(pathToResolve, constants_1.BEST_CONFIG);
    if (isFile(bestConfig)) {
        return bestConfig;
    }
    const packageJson = path_1.default.resolve(pathToResolve, constants_1.PACKAGE_JSON);
    if (isFile(packageJson)) {
        return packageJson;
    }
    if (pathToResolve === path_1.default.dirname(pathToResolve)) {
        throw new Error(`No config found in ${initialPath}`);
    }
    // go up a level and try it again
    return resolveConfigPathByTraversing(path_1.default.dirname(pathToResolve), initialPath, cwd);
}
function resolveConfigPath(pathToResolve, cwd) {
    const absolutePath = path_1.default.isAbsolute(pathToResolve) ? pathToResolve : path_1.default.resolve(cwd, pathToResolve);
    if (isFile(absolutePath)) {
        return absolutePath;
    }
    return resolveConfigPathByTraversing(absolutePath, pathToResolve, cwd);
}
function readConfigAndSetRootDir(configPath) {
    const isJSON = configPath.endsWith('.json');
    let configObject;
    try {
        configObject = require(configPath);
    }
    catch (error) {
        if (isJSON) {
            throw new Error(`Best: Failed to parse config file ${configPath}\n`);
        }
        else {
            throw error;
        }
    }
    if (configPath.endsWith(constants_1.PACKAGE_JSON)) {
        if (!configObject.best) {
            throw new Error(`No "best" section has been found in ${configPath}`);
        }
        configObject = configObject.best;
    }
    if (!configObject) {
        throw new Error("Couldn't find any configuration for Best.");
    }
    if (configObject.rootDir) {
        // We don't touch it if it has an absolute path specified
        if (!path_1.default.isAbsolute(configObject.rootDir)) {
            // otherwise, we'll resolve it relative to the file's __dirname
            configObject.rootDir = path_1.default.resolve(path_1.default.dirname(configPath), configObject.rootDir);
        }
    }
    else {
        // If rootDir is not there, we'll set it to this file's __dirname
        configObject.rootDir = path_1.default.dirname(configPath);
    }
    if (!configObject.projectName) {
        throw new Error('A best project must have a projectName');
    }
    return configObject;
}
function ensureNoDuplicateConfigs(parsedConfigs, projects) {
    const configPathSet = new Set();
    for (const { configPath } of parsedConfigs) {
        if (configPathSet.has(configPath)) {
            let message = 'One or more specified projects share the same config file\n';
            parsedConfigs.forEach((projectConfig, index) => {
                message =
                    message +
                        '\nProject: "' +
                        projects[index] +
                        '"\nConfig: "' +
                        String(projectConfig.configPath) +
                        '"';
            });
            throw new Error(message);
        }
        if (configPath !== null) {
            configPathSet.add(configPath);
        }
    }
}
//# sourceMappingURL=resolve-config.js.map